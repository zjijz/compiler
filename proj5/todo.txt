MIPS Code (NEEDS TESTING):
Registers: ($t0 - $t9)
-syscall for read (syscall 5)
-syscall for print (syscall 1)
-code to add two numbers
-code to subtract two numbers
-code to set a register with to a new value
-code to read from RAM
-code to write to RAM
-(helper) swap variables in/out of RAM
-(helper) repeated addition
-(helper) repeated subtraction
_______________________________
Methods
-start (~done)
-finish (~done)
-assign (~done)
-process (~done?)
-expression (still needs evaluation of many variables added together)
-read (nothing done)
-write (nothing done)
-Tree names need to be redone for better readability
_______________________________
Pretty Print for Sym_table, reg_table, and var_queue
_______________________________
Testing
- read multiple variables
- write multiple variables
- write multiple expressions
- when primary is '( expression )'
- when RHS of assignment is x + y + 2 or something like that
- when RHS is a mix of variables assigned normally and through read
_______________________________
Queue for Recent Variables
-When variables are loaded into registers, push them to queue
-When you need to remove a variable from a register to make space,
 the one you remove is whatever the queue pops
-Could optimize this to better keep variables in registers to minimize
 read/write to RAM
  - LinkedList to be able to easily move values already on list when seeing them?
 ______________________________
 Abstractt and merge _process_id and _assign_id more
 - these methods are very similar, except one throws a Semantic Error when it finds a variable that isn't initialized
 ______________________________
 Helper function to make dictionaries for use with var_queue
 ______________________________
 Make a module that houses all exceptions instead of being spread out
 ______________________________
 Compiler Flags
 -Debug flag (turn parser and compiler debugging on)
 ______________________________
 Optimizations:
 - Keeping track of current variable values in sym_table to further reduce calls to read from RAM
   (Since initialization can be done with immediates instead of loading addresses and values)
   - Done for 'int'
 - Making use of more registers ($s's?)
 - Change Queue to be a more complete LinkedList
 - Allowing a register to track more than one variable (for instance, in situations of equality)
   - The register would then just have to know it has two values, and save off both whenever the register is freed
 - Keep track of number in $v0


